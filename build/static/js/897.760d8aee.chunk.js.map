{"version":3,"file":"static/js/897.760d8aee.chunk.js","mappings":"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","sources":["../.yarn/cache/@babel-runtime-npm-7.22.5-0a6711d04c-12a50b7de2.zip/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../.yarn/cache/@babel-runtime-npm-7.22.5-0a6711d04c-12a50b7de2.zip/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../.yarn/cache/@babel-runtime-npm-7.22.5-0a6711d04c-12a50b7de2.zip/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../.yarn/cache/@babel-runtime-npm-7.22.5-0a6711d04c-12a50b7de2.zip/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../.yarn/cache/@babel-runtime-npm-7.22.5-0a6711d04c-12a50b7de2.zip/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../.yarn/cache/@babel-runtime-npm-7.22.5-0a6711d04c-12a50b7de2.zip/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../.yarn/cache/@babel-runtime-npm-7.22.5-0a6711d04c-12a50b7de2.zip/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","starbattle/types.ts","starbattle/utils.ts","starbattle/solver.worker.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","\r\nexport enum Cell {\r\n    BLANK,\r\n    STAR,\r\n    X,\r\n}\r\n\r\nexport type PuzzleStep = {\r\n    indices?: number[]\r\n    otherIndices?: number[]\r\n    type?: Cell\r\n    message?: string\r\n}\r\n\r\nexport type PuzzleData = {\r\n    cells: Cell[]\r\n    size: number\r\n    starCount: number\r\n    rows: number[][]\r\n    columns: number[][]\r\n    groups: number[][]\r\n    cellIndexToGroupIndex: number[]\r\n}","import { Cell, PuzzleData, PuzzleStep } from './types';\n\n/**\n * Analyzes a puzzle state to identify any rule violations.\n *\n * @param {PuzzleData} puzzleData - The current state of the puzzle, including cell configurations, \n *                                  puzzle size, star count, and structure of rows, columns, and groups.\n * @returns {PuzzleStep} Returns a PuzzleStep object containing error details if a violation is found; \n *                       otherwise, returns an empty object.\n *\n * This function checks for basic StarBattle puzzle rules, such as ensuring that stars are not adjacent \n * (even diagonally) and that each row, column, and group has the correct number of stars. If an error \n * is found, it returns the indices of the problematic cells and an error message.\n */\nexport function getSolutionError(puzzleData: PuzzleData): PuzzleStep {\n    const { cells, size, starCount, rows, columns, groups } = puzzleData\n    let error = findSimpleError()\n    if (error) return error\n    // return { message: \"Unsolvable\" }\n    return {}\n\n    function findSimpleError(): PuzzleStep | undefined {\n        // for each cell with star, surrounding cells must have no star\n        for (const [i, cell] of cells.entries()) {\n            if (cell !== Cell.STAR) continue\n            const starNeighbour = getNeighbouringIndices(size, i).find(index => cells[index] === Cell.STAR)\n            if (starNeighbour === undefined) continue\n            return {\n                indices: [i, starNeighbour],\n                message: \"Stars cannot be next to each other.\",\n            }\n        }\n        // each row, column, group must have at most n stars\n        let error = processTooManyStarsRule(rows, \"row\")\n        if (error) return error\n        error = processTooManyStarsRule(columns, \"column\")\n        if (error) return error\n        error = processTooManyStarsRule(groups, \"group\")\n        if (error) return error\n        error = processNotEnoughSpacesRule(rows, \"row\")\n        if (error) return error\n        error = processNotEnoughSpacesRule(columns, \"column\")\n        if (error) return error\n        error = processNotEnoughSpacesRule(groups, \"group\")\n        if (error) return error\n    }\n\n    function processTooManyStarsRule(targetGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of targetGroups) {\n            if (getStarCount(group, cells) > starCount) {\n                return {\n                    indices: group,\n                    message: `This ${name} contains too many stars.`\n                }\n            }\n        }\n    }\n\n    function processNotEnoughSpacesRule(targetGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of targetGroups) {\n            if (starCount - getStarCount(group, cells) > getCellCount(group, cells, Cell.BLANK)) {\n                return {\n                    indices: group,\n                    message: `This ${name} contains too few blank spaces.`\n                }\n            }\n        }\n    }\n\n}\n\n/**\n * Attempts to find a solution for the given puzzle data and returns the solved state as an array of cells.\n *\n * @param {PuzzleData} puzzleData - The puzzle data, including the current state of the puzzle grid\n *                                  and configuration settings like puzzle size and star count.\n * @returns {Cell[] | undefined} Returns an array of cells representing the solved state of the puzzle\n *                               if a solution is found. Each cell in the array represents a specific\n *                               state (e.g., empty, star, etc.) in the puzzle grid. Returns undefined\n *                               if no solution is found.\n *\n * This function applies solving algorithms to the provided puzzle data in an attempt to find a valid\n * solution. It employs logical rules and techniques specific to StarBattle puzzles to determine the\n * placement of stars. If a solution is found, the function returns the solved state, which can be used\n * to update the puzzle grid in the user interface. If the puzzle is unsolvable, it returns undefined.\n */\nexport function findSolution(puzzleData: PuzzleData): Cell[] | undefined  {\n    const { size, starCount, rows, columns, groups, cellIndexToGroupIndex } = puzzleData\n    let backup = puzzleData.cells\n    puzzleData.cells = backup.slice()\n    let { cells } = puzzleData\n    const guesses: number[] = []\n    const res = findSolutionHelper()\n    puzzleData.cells = backup\n    console.log(\"After solution helper, res:\", res)\n    if (res) return res\n\n    function findSolutionHelper(startIndex: number = 0): Cell[] | undefined {\n        console.log(\"In findSolutionHelper\", startIndex)\n        // Early failure check\n        if (pastUnfinishedGroup(startIndex, groups, cells, starCount)) return\n        // Use logic where possible\n        const err = applyNextSteps(puzzleData)\n        if (err !== undefined) return\n        console.log(\"After logic\")\n        // Successful base case\n        if (isSolved(puzzleData)) return cells\n        // Otherwise, guess and check\n        for (let i = startIndex; i < cells.length; i++) {\n            if (pastUnfinishedGroup(i, groups, cells, starCount)) break\n            if (cells[i] !== Cell.BLANK) continue\n            // getNextStep should have already marked the following with X, so they shouldn't need to be checked\n            if (getNeighbouringIndices(size, i).find(neighbour => cells[neighbour] === Cell.STAR)) continue\n            if (getStarCount(groups[cellIndexToGroupIndex[i]], cells) === starCount) continue\n            const {x, y} = getCoords(i, size)\n            if (getStarCount(rows[y], cells) === starCount) continue\n            if (getStarCount(columns[x], cells) === starCount) continue\n            const backup = cells.slice()\n            cells[i] = Cell.STAR\n            guesses.push(i)\n            console.log(\"guesses,\", guesses.map(g => {\n                const { x, y } = getCoords(g, size)\n                return [g, x, y]\n            }))\n            const res = findSolutionHelper(i + 1)\n            if (res) {\n                return res\n            }\n            // Guess was wrong\n            cells = backup\n            puzzleData.cells = cells\n            cells[i] = Cell.X\n            guesses.pop()\n            const err = applyNextSteps(puzzleData)\n            if (err !== undefined) return\n        }\n        // Unsuccessful base case\n    }\n}\n\nfunction applyNextSteps(puzzleData: PuzzleData, maxGuesses: number = 0) {\n    const backup = puzzleData.cells\n    puzzleData.cells = backup.slice()\n    try {\n        while (true) {\n            let nextStep = getNextStep(puzzleData, maxGuesses)\n            const newCells = applyNextStep(puzzleData.cells, nextStep, true)\n            if (!newCells) return\n            const error = getSolutionError(puzzleData)\n            if (error.message) {\n                console.log(\"Found error\", error)\n                return error\n            }\n        }\n    } finally {\n        puzzleData.cells = backup\n    }\n}\n\nfunction pastUnfinishedGroup(cutoff: number, groups: number[][], cells: Cell[], starCount: number): boolean {\n    for (const group of groups) {\n        if (getStarCount(group, cells) === starCount) continue\n        if (group[group.length - 1] < cutoff) {\n            console.log(`cutoff: ${cutoff} group: ${group}`)\n            return true\n        }\n    }\n    return false\n}\n\n/**\n * Determines if the puzzle is solved.\n *\n * @param {PuzzleData} puzzleData - The current state of the puzzle, including the grid configuration \n *                                  and other relevant data.\n * @returns {boolean} Returns true if the puzzle is correctly solved, otherwise false.\n *\n * This function checks the entire state of the puzzle to determine if it meets all the criteria for \n * being solved. It evaluates if the correct number of stars are placed according to the game rules and \n * verifies that no rule violations exist in the current configuration.\n */\nexport function isSolved(puzzleData: PuzzleData): boolean {\n    const { cells, size, starCount, rows, columns, groups } = puzzleData\n    // for each cell that have a star, surrounding cells must have no star\n    for (let i = 0; i < cells.length; i++) {\n        if (cells[i] === Cell.STAR) {\n            if (getNeighbouringIndices(size, i).find(neighbour => cells[neighbour] === Cell.STAR)) {\n                return false\n            }\n        }\n    }\n    // each row, column, group must have exactly n stars\n    for (const row of rows) {\n        if (getStarCount(row, cells) != starCount) return false\n    }\n    for (const column of columns) {\n        if (getStarCount(column, cells) != starCount) return false\n    }\n    for (const group of groups) {\n        if (getStarCount(group, cells) != starCount) return false\n    }\n    return true\n}\n\n/**\n * Counts the number of stars in a specified group of cells.\n *\n * @param {number[]} group - An array of indices representing a group of cells in the puzzle.\n * @param {Cell[]} cells - An array of cells representing the current state of the puzzle.\n * @returns {number} Returns the count of stars present in the specified group.\n *\n * This function calculates the number of cells in the provided group that are marked as stars. It is\n * commonly used to verify puzzle rules related to star count in rows, columns, or regions.\n */\nfunction getStarCount(group: number[], cells: Cell[]): number {\n    return getCellCount(group, cells, Cell.STAR)\n}\n\n/**\n * Counts the number of cells of a specific type in a given group.\n *\n * @param {number[]} group - An array of indices representing a group of cells in the puzzle.\n * @param {Cell[]} cells - An array of cells representing the current state of the puzzle.\n * @param {Cell} cellType - The type of cell to count (e.g., Cell.STAR, Cell.EMPTY).\n * @returns {number} Returns the count of cells of the specified type in the group.\n *\n * This function calculates how many cells of a specific type are present in the provided group.\n * It is a general utility function used to count various types of cells, like stars or empty cells,\n * in a specific part of the puzzle.\n */\nfunction getCellCount(group: number[], cells: Cell[], cellType: Cell): number {\n    return group.filter(index => cells[index] === cellType).length\n}\n\n/**\n * Determines the next logical step in solving the puzzle.\n *\n * @param {PuzzleData} puzzleData - The current state of the puzzle, including the grid configuration \n *                                  and other relevant data.\n * @returns {PuzzleStep} Returns a PuzzleStep object representing the next step in the puzzle-solving\n *                       process. This includes details about the action to be taken and any relevant\n *                       indices or messages.\n *\n * This function analyzes the current state of the puzzle and identifies the next logical move that\n * brings the puzzle closer to a solution. It applies various solving techniques and rules specific to\n * StarBattle puzzles to deduce this next step. The returned PuzzleStep can then be used to update the\n * puzzle state or guide the user on what action to take next.\n */\nexport function getNextStep(puzzleData: PuzzleData, maxGuesses: number = 0): PuzzleStep {\n    const { cells, size, starCount, rows, columns, groups, cellIndexToGroupIndex } = puzzleData\n    // apply each rule and return first match\n    // for all groups, rows, columns, return if remainingStars == remainingSpaces\n    const confirmedPartitions: number[][] = []\n    const neighbours = getAllNeighbouringIndices(size)\n    let nextStep = processLastSpacesRule(groups, \"group\")\n    if (nextStep) return nextStep\n    nextStep = processLastSpacesRule(rows, \"row\")\n    if (nextStep) return nextStep\n    nextStep = processLastSpacesRule(columns, \"column\")\n    if (nextStep) return nextStep\n\n    for (const [i, cell] of cells.entries()) {\n        if (cell === Cell.X) continue\n        if (cell !== Cell.STAR) continue\n        const indices = getNeighbouringIndices(size, i).filter(index => cells[index] !== Cell.X)\n        if (indices.length === 0) continue\n        return {\n            indices,\n            type: Cell.X,\n            message: `Stars cannot be placed in cells neighbouring a star (including diagonals).`\n        }\n    }\n\n    nextStep = processNoStarsLeftRule(groups, \"group\")\n    if (nextStep) return nextStep\n    nextStep = processNoStarsLeftRule(rows, \"row\")\n    if (nextStep) return nextStep\n    nextStep = processNoStarsLeftRule(columns, \"column\")\n    if (nextStep) return nextStep\n    \n    for (const [i, cell] of cells.entries()) {\n        if (cell === Cell.X) continue\n        const group = findNeighbouringGroup(i)\n        if (!group) continue\n        return {\n            indices: [i],\n            otherIndices: group,\n            type: Cell.X,\n            message: `A star cannot be placed here. Otherwise, not enough stars can be placed within this group.`\n        }\n    }\n    // For each blank cell, imagine what would happen if it was a star - set neighbours to x, check # of blocks for the groups/columns/rows they are in\n    for (const [i, cell] of cells.entries()) {\n        if (cell !== Cell.BLANK) continue\n        const neighbours = getNeighbouringIndices(size, i).filter(index => cells[index] === Cell.BLANK)\n        const groupIndices = new Set(neighbours.map(index => cellIndexToGroupIndex[index]))\n        const relevantGroups = Array.from(groupIndices).map(index => groups[index])\n        nextStep = processNoCrowdingRule(i, neighbours, relevantGroups, \"group\")\n        if (nextStep) return nextStep\n        const rowIndices = new Set(neighbours.map(index => getCoords(index, size).y))\n        const relevantRows = Array.from(rowIndices).map(index => rows[index])\n        nextStep = processNoCrowdingRule(i, neighbours, relevantRows, \"row\")\n        if (nextStep) return nextStep\n        const columnIndices = new Set(neighbours.map(index => getCoords(index, size).x))\n        const relevantColumns = Array.from(columnIndices).map(index => columns[index])\n        // console.log(i, neighbours, columnIndices, relevantColumns)\n        nextStep = processNoCrowdingRule(i, neighbours, relevantColumns, \"column\")\n        if (nextStep) return nextStep\n    }\n    nextStep = processBlockRule(groups, \"group\")\n    if (nextStep) return nextStep\n    nextStep = processBlockRule(rows, \"row\")\n    if (nextStep) return nextStep\n    nextStep = processBlockRule(columns, \"column\")\n    if (nextStep) return nextStep\n    for (const lineCount of range(1, size)) {\n        for (const start of range(0, size - lineCount + 1)) {\n            // console.log(\"lineCount\", lineCount, \"start\", start, \"end\", size - lineCount + 1)\n            nextStep = processGroupsFillLinesRule(rows.slice(start, start + lineCount), \"row\")\n            if (nextStep) return nextStep\n            nextStep = processGroupsFillLinesRule(columns.slice(start, start + lineCount), \"column\")\n            if (nextStep) return nextStep\n        }\n    }\n    const twoRowGroups = range(0, size - 2 + 1).map(start => rows.slice(start, start + 2).flat())\n    nextStep = processBlockRule(twoRowGroups, \"row\", 2 * starCount)\n    if (nextStep) return nextStep\n    const twoColumnGroups = range(0, size - 2 + 1).map(start => columns.slice(start, start + 2).flat())\n    nextStep = processBlockRule(twoColumnGroups, \"column\", 2 * starCount)\n    if (nextStep) return nextStep\n    nextStep = processConfirmedBlockRule(twoRowGroups, \"row\", 2 * starCount)\n    if (nextStep) return nextStep\n    nextStep = processConfirmedBlockRule(twoColumnGroups, \"column\", 2 * starCount)\n    if (nextStep) return nextStep\n    nextStep = processConfirmedBlockRule(groups, \"group\", 2 * starCount)\n    if (nextStep) return nextStep\n    // nextStep = processCombinedGroupBlockRule()\n    // if (nextStep) return nextStep\n    // TODO: this can be slow, especially when maxGuesses > 1\n    if (maxGuesses > 0) {\n        for (const [i, cell] of cells.entries()) {\n            if (cell !== Cell.BLANK) continue\n            cells[i] = Cell.STAR\n            const error = applyNextSteps(puzzleData, maxGuesses - 1)\n            cells[i] = Cell.BLANK\n            // A star here would lead to an error, so there can be no star here\n            if (error)\n                return {\n                    indices: [i],\n                    type: Cell.X,\n                    message: `A star cannot be placed here. Otherwise, a rule violation will eventually occur.`\n                }\n        }\n    }\n    return {message: 'Unknown'}\n\n    function starCanBePlaced(i: number) {\n        if (cells[i] !== Cell.BLANK) return false\n        if (neighbours[i].some(index => cells[index] === Cell.STAR)) return false\n        if (getRemainingStarCount(cells, groups[cellIndexToGroupIndex[i]], starCount) === 0) return false\n        const { x, y } = getCoords(i, size)\n        if (getRemainingStarCount(cells, rows[y], starCount) === 0) return false\n        if (getRemainingStarCount(cells, columns[x], starCount) === 0) return false\n        return true\n    }\n\n    function starsCanBePlaced(indices: number[]) {\n        for (const i of indices) {\n            if (!starCanBePlaced(i)) return false\n            if (neighbours[i].some(index => indices.includes(index))) return false\n        }\n        return true\n    }\n    \n    function getSharedNeighbour(indices: number[]): number[] {\n        let neighbours = getNeighbouringIndices(size, indices[0])\n        for (const i of indices.slice(1)) {\n            let otherNeighbours = getNeighbouringIndices(size, i)\n            neighbours = neighbours.filter(index => otherNeighbours.includes(index))\n        }\n        return neighbours\n    }\n\n    function findNeighbouringGroup(i: number): number[] | undefined {\n        const neighbours = getNeighbouringIndices(size, i)\n        for (let group of groups) {\n            group = group.filter(index => cells[index] === Cell.BLANK)\n            if (group.length === 0) continue\n            if (group.every(index => neighbours.includes(index))) return group\n        }\n    }\n\n    function findSharedRow(group: number[]): number | undefined {\n        const {y} = getCoords(group[0], size)\n        if (group.every(index => cells[index] === Cell.X || getCoords(index, size).y === y)) return y\n    }\n\n    function findSharedColumn(group: number[]): number | undefined {\n        const {x} = getCoords(group[0], size)\n        if (group.every(index => cells[index] === Cell.X || getCoords(index, size).x === x)) return x\n    }\n\n    function findSharedGroups(indices: number[], targetCount: number): number[] | undefined {\n        const groups: Set<number> = new Set()\n        for (const index of indices) {\n            groups.add(cellIndexToGroupIndex[index])\n            if (groups.size > targetCount) return\n        }\n        return Array.from(groups)\n    }\n\n    function processLastSpacesRule(targetGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of targetGroups) {\n            const indices = group.filter(index => cells[index] === Cell.BLANK)\n            if (indices.length === 0) continue\n            if (!starsCanBePlaced(indices)) continue\n            if (getRemainingStarCount(cells, group, starCount) === indices.length)\n                return {\n                    indices,\n                    type: Cell.STAR,\n                    message: `The remaining stars in this ${name} can only be placed here.`\n                }\n        }\n    }\n\n    function processNoStarsLeftRule(targetGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of targetGroups) {\n            if (getRemainingStarCount(cells, group, starCount) === 0) {\n                const indices = group.filter(index => cells[index] === Cell.BLANK)\n                if (indices.length === 0) continue\n                return {\n                    indices,\n                    type: Cell.X,\n                    message: `No more stars can be placed in this ${name}.`\n                }\n            }\n        }\n    }\n\n    /* For example, if all the cells in 2 adjacent rows are in 2 groups, the stars in those groups\n        must be in those rows. The rest of the cells in those groups cannot contain stars.\n     */\n    function processGroupsFillLinesRule(lines: number[][], name: string): PuzzleStep | undefined {\n        const lineIndices = lines.flat().filter(index => cells[index] !== Cell.X)\n        const groupIndices = findSharedGroups(lineIndices, lines.length)\n        if (typeof groupIndices === 'undefined') return\n        // console.log(\"line\", lineIndices, \"group\", groupIndices, groupIndices.map(groupIndex => groups[groupIndex]).flat())\n        const indices = groupIndices.map(groupIndex => groups[groupIndex])\n            .flat()\n            .filter(index => !lineIndices.includes(index) && cells[index] !== Cell.X)\n        if (indices.length === 0) return\n        const groupsText = lines.length > 1 ? \"these groups\" : \"this group\"\n        const linesText = lines.length > 1 ? `these ${name}s` : `this ${name}`\n        return {\n            indices,\n            otherIndices: lineIndices,\n            type: Cell.X,\n            message: `Stars cannot be placed in ${groupsText} outside ${linesText}. Otherwise, there will not be enough stars in ${linesText}.`\n        }\n    }\n\n    function processNoCrowdingRule(i: number, neighbours: number[], relevantGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of relevantGroups) {\n            const remainingGroup = group.filter(index => cells[index] === Cell.BLANK && !neighbours.includes(index))\n            // console.log(i, name, group, remainingGroup)\n            const partitions = partitionCells(size, remainingGroup)\n            if (partitions.length >= getRemainingStarCount(cells, group, starCount)) continue\n            return {\n                indices: [i],\n                otherIndices: group,\n                type: Cell.X,\n                message: `A star cannot be placed here. Otherwise the indicated ${name} will not have enough room for stars.`\n            }\n        }\n    }\n\n    function processBlockRule(targets: number[][], name: string, starCountPerTarget: number = starCount): PuzzleStep | undefined {\n        for (const target of targets) {\n            const blankGroup = target.filter(index => cells[index] === Cell.BLANK)\n            const partitions = partitionCells(size, blankGroup)\n            const remainingStarCount = getRemainingStarCount(cells, target, starCountPerTarget)\n            // console.log(\"target\", target, \"parts\", partitions, \"remainingStarCount\", remainingStarCount)\n            if (partitions.length !== remainingStarCount) continue\n            partitions.forEach(partition => addConfirmedPartition(partition))\n            const multipleLeft = remainingStarCount > 1\n            const multipleGroup = starCountPerTarget > starCount\n            const baseMessage = `There can be at most 1 star in each 2x2 block. When the remaining space \n                within ${multipleGroup ? 'these': 'this'}  ${name}${multipleGroup ? 's' : ''} is split into blocks at most 2x2 in size, \n                there ${multipleLeft ? 'are' : 'is'} only ${remainingStarCount} block${multipleLeft ? 's' : ''}, \n                which is equal to the number of remaining stars. \n                Therefore, each block must contain a star.`.replaceAll('\\n', '')\n            for (const partition of partitions) {\n                if (partition.length === 1) {\n                    if (starCanBePlaced(partition[0]))\n                        return {\n                            indices: partition,\n                            otherIndices: target,\n                            type: Cell.STAR,\n                            message: baseMessage + ` This block only has one space, so it must be a star.`\n                        }\n                }\n                const indices = getSharedNeighbour(partition).filter(index => cells[index] != Cell.X)\n                if (indices.length === 0) continue\n                return {\n                    indices,\n                    otherIndices: blankGroup,\n                    type: Cell.X,\n                    message: baseMessage + ` If stars are placed here, there will be no place to put a star in this block.`\n                }\n            }\n        }\n    }\n\n    // The block rule can be applied to multiple groups joined as one.\n    // There may be fewer partitions as some may stretch across group borders\n    // TODO: too slow; is there a faster way?\n    function processCombinedGroupBlockRule(): PuzzleStep | undefined {\n        // For each group, find neighbours (with greater index)\n        const groupNeighbours = getGroupNeighbours()\n        console.log(groupNeighbours)\n        // Choose # of groups to combine\n        for (let groupCount = 2; groupCount <= groups.length; groupCount++) {\n            // For each selection of groups, partition\n            console.log(\"groupCount\", groupCount)\n            for (const i of range(0, groups.length - groupCount + 1)) {\n                const selections = getSelections([[i]], groupCount)\n                console.log(i, selections)\n                if (selections.length === 0) continue\n                const combinedGroups = selections.map(selection => {\n                    return selection.map(groupIndex => groups[groupIndex]).flat()\n                })\n                const nextStep = processBlockRule(combinedGroups, \"group\", groupCount * starCount)\n                if (nextStep) return nextStep\n            }\n\n        }\n\n        // gets a combination of neighbouring groups\n        // TODO: currently gets all paths, but is there a way to get combinations instead?\n        function getSelections(inProgress: number[][], groupCount: number): number[][] {\n            if (inProgress.length === 0) return inProgress\n            if (inProgress[0].length === groupCount) return inProgress\n            const selections: number[][] = []\n            for (const selection of inProgress) {\n                const candidates = getCandidates(selection)\n                if (candidates.length === 0) continue\n                for (const candidate of candidates) {\n                    selections.push([...selection, candidate])\n                }\n            }\n            return getSelections(selections, groupCount)\n        }\n\n        function getCandidates(selection: number[]) {\n            return Array.from(new Set(selection.map(index => groupNeighbours[index])\n                                               .flat()\n                                               .filter(index => !selection.includes(index))))\n        }\n    }\n\n    function getGroupNeighbours() {\n        const blankGroups = groups.map(group => group.filter(i => cells[i] === Cell.BLANK))\n        // true if some blank cell in group is next to some blank cell in other\n        return blankGroups.map((group1, index1) => {\n            return blankGroups.map((group2, index2) => {\n                if (index1 >= index2) return -1\n                return group1.some(i => group2.some(j => isNeighbour(i, j)))\n                    ? index2\n                    : -1\n            }).filter(val => val !== -1)\n        })\n    }\n\n    function isNeighbour(i: number, j: number) {\n        return getNeighbouringIndices(size, i).includes(j)\n    }\n    \n    function addConfirmedPartition(partitionToAdd: number[]) {\n        const subsetIndex = confirmedPartitions.findIndex(partition => {\n            return partition.length <= partitionToAdd.length\n                && partition.every(index => partitionToAdd.includes(index))\n        })\n        if (subsetIndex > -1) return\n        const supersetIndex = confirmedPartitions.findIndex(partition => {\n            return partition.length > partitionToAdd.length\n                && partitionToAdd.every(index => partition.includes(index))\n        })\n        if (supersetIndex > -1) return confirmedPartitions[supersetIndex] = partitionToAdd\n        confirmedPartitions.push(partitionToAdd)\n    }\n\n    /* When processing the block rule, for example in 2 rows, suppose we find partitions that match the remaining star count.\n        These partitions are confirmed to have a star in each. When partitioning 2 columns for example, if we find one of the\n        confirmed partitions again with 1 remaining star in the 2 columns, since we know a star has to be in that partition,\n        we can exclude the spaces in the 2 columns outside the partition.\n     */\n    function processConfirmedBlockRule(groups: number[][], name: string, starCountPerGroup: number = starCount): PuzzleStep | undefined {\n        for (const group of groups) {\n            const remainingStarCount = getRemainingStarCount(cells, group, starCountPerGroup)\n            if (remainingStarCount !== 1) continue\n            const blankGroup = group.filter(index => cells[index] === Cell.BLANK)\n            const match = confirmedPartitions.find(partition => partition.every(index => group.includes(index)))\n            if (match === undefined) continue\n            const indices = blankGroup.filter(index => !match.includes(index))\n            if (indices.length === 0) continue\n            const multipleGroup = starCountPerGroup > starCount\n            return {\n                indices,\n                otherIndices: blankGroup,\n                type: Cell.X,\n                message: `There can be at most 1 star in each 2x2 block. The indicated block is confirmed to have a star \n                            from splitting some columns, rows, or groups into blocks, so we can exclude the spaces within \n                            ${multipleGroup ? 'these': 'this'} ${name}${multipleGroup ? 's' : ''} outside the block .`.replaceAll('\\n', '')\n            }\n        }\n    }\n}\n\n/**\n * Calculates the number of stars yet to be placed in a specific group.\n *\n * @param {Cell[]} cells - An array of cells representing the current state of the puzzle.\n * @param {number[]} group - An array of indices representing a group of cells in the puzzle.\n * @param {number} starCountPerGroup - The required number of stars per group.\n * @returns {number} The number of stars still needed to meet the required count in the group.\n *\n * This function determines how many more stars need to be placed in a given group to meet the\n * specified star count. It is useful for guiding the puzzle solving process.\n */\nfunction getRemainingStarCount(cells: Cell[], group: number[], starCountPerGroup: number) {\n    return starCountPerGroup - group.filter(index => cells[index] === Cell.STAR).length\n}\n\n/**\n * Applies the next step in the puzzle solving process to the puzzle grid.\n *\n * @param {Cell[]} cells - The current state of the puzzle grid.\n * @param {PuzzleStep} nextStep - The next step to apply, including indices and cell types.\n * @param {boolean} inPlace - Whether to modify the cells array in place. Default is false.\n * @returns {Cell[] | undefined} The updated puzzle grid after applying the step, or undefined if no action is taken.\n *\n * This function updates the puzzle grid based on the provided next step, which may involve placing or removing\n * stars or other actions. If 'inPlace' is true, the original grid is modified; otherwise, a new grid is returned.\n */\nexport function applyNextStep(cells: Cell[], nextStep: PuzzleStep, inPlace: boolean = false) {\n    const newCells = inPlace ? cells : cells.slice()\n    const { indices, type } = nextStep\n    if (indices === undefined || indices.length === 0 || type === undefined) return\n    indices.forEach(index => newCells[index] = type)\n    return newCells\n}\n\n/**\n * Gets the indices of all neighboring cells for a given cell in the puzzle grid.\n *\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @param {number} i - The index of the cell for which to find neighbors.\n * @returns {number[]} An array of indices representing neighboring cells.\n *\n * This function calculates the indices of all cells adjacent (including diagonally) to a given cell\n * in the grid. It is used to check puzzle rules related to neighboring cells.\n */\nexport function getNeighbouringIndices(size: number, i: number): number[] {\n    const { x, y } = getCoords(i, size)\n    return [\n        [x - 1, y - 1],\n        [x, y - 1],\n        [x + 1, y - 1],\n        [x - 1, y],\n        [x + 1, y],\n        [x - 1, y + 1],\n        [x, y + 1],\n        [x + 1, y + 1],\n    ].filter(([x, y]) => x >= 0 && x < size && y >= 0 && y < size)\n    .map(([x, y]) => getIndex(x, y, size))\n}\n\n/**\n * Generates a list of neighboring indices for every cell in the puzzle grid.\n *\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @returns {Cell[][]} An array where each element is an array of neighboring indices for each cell in the grid.\n *\n * This function is a utility to pre-calculate and store all neighboring indices for each cell in the grid,\n * potentially optimizing operations that frequently require this information.\n */\nexport function getAllNeighbouringIndices(size: number): Cell[][] {\n    return range(0, size**2).map(i => getNeighbouringIndices(size, i))\n}\n\n/**\n * Converts a linear index into x, y coordinates in the puzzle grid.\n *\n * @param {number} i - The linear index to convert.\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @returns {{ x: number, y: number }} An object containing the x and y coordinates corresponding to the index.\n *\n * This function is used to translate between a linear array representation of the puzzle grid\n * and a two-dimensional coordinate system.\n */\nexport function getCoords(i: number, size: number): { x: number, y: number} {\n    return {\n        x: i % size,\n        y: Math.floor(i / size),\n    }\n}\n\n/**\n * Converts x, y coordinates to a linear index in the puzzle grid.\n *\n * @param {number} x - The x coordinate.\n * @param {number} y - The y coordinate.\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @returns {number} The linear index corresponding to the x, y coordinates.\n *\n * This function is the inverse of 'getCoords', translating two-dimensional coordinates into\n * a linear index in the puzzle's array representation.\n */\nexport function getIndex(x: number, y: number, size: number): number {\n    return y * size + x\n}\n\n/**\n * Partitions a set of cell indices into groups where each group forms a 2x2 block.\n *\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @param {number[]} indices - The indices of cells to be partitioned.\n * @returns {number[][]} An array of groups, each group being a 2x2 block of cell indices.\n *\n * This function is used in solving processes to group cells into blocks that conform to the\n * StarBattle puzzle rule: each 2x2 block can contain at most one star.\n */\nexport function partitionCells(size: number, indices: number[]): number[][] {\n    const partitions: number[][] = []\n    // for each index\n    for (const i of indices) {\n        // if it fits into existing partitions, add it\n        let foundExisting = false\n        for (const partition of partitions) {\n            if (withinSquare(size, i, partition)) {\n                partition.push(i)\n                foundExisting = true\n                break\n            }\n        }\n        // if not, make a new partition\n        if (!foundExisting) {\n            partitions.push([i])\n        }\n    }\n    // todo: guarantee that # of partitions is minimalized\n    return partitions\n}\n\n/**\n * Determines if a given cell is within a 2x2 square area of all cells in a group.\n *\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @param {number} i - The index of the cell to check.\n * @param {number[]} group - An array of indices representing a group of cells in the puzzle.\n * @returns {boolean} Returns true if the specified cell is within a 2x2 square area of every cell in the group.\n *\n * This function checks whether the cell at index 'i' is within a 1-cell radius (forming a 2x2 square)\n * of every other cell in the provided group. It is useful for implementing rules that depend on the\n * proximity of cells within the puzzle grid, such as ensuring that stars in a StarBattle puzzle are not\n * placed too close to each other.\n */\nfunction withinSquare(size: number, i: number, group: number[]) {\n    const { x, y } = getCoords(i, size)\n    return group.every(index => {\n        const {x: otherX, y: otherY} = getCoords(index, size)\n        return (Math.abs(x - otherX) <= 1 && Math.abs(y - otherY) <= 1)\n    })\n}\n\n// Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#sequence_generator_range\n/**\n * Creates an array of numbers within a specified range.\n *\n * @param {number} start - The start value of the range.\n * @param {number} stop - The end value of the range.\n * @param {number} step - The step size between each number in the range.\n * @returns {number[]} An array containing the sequence of numbers.\n *\n * This utility function generates a sequence of numbers starting from 'start', ending at 'stop',\n * and incrementing by 'step'. It is useful for creating numeric arrays for iteration and indexing.\n */\nexport function range(start: number, stop: number, step: number = 1): number[] {\n    return Array.from({ length: (stop - 1 - start) / step + 1 }, (_, i) => start + i * step)\n}\n\n/**\n * Checks if the given coordinates are out of bounds for a grid of specified dimensions.\n *\n * @param {number} x - The x coordinate to check.\n * @param {number} y - The y coordinate to check.\n * @param {number} xSize - The horizontal size (width) of the grid.\n * @param {number} ySize - The vertical size (height) of the grid.\n * @returns {boolean} True if the coordinates are out of bounds, false otherwise.\n *\n * This function is used to validate whether given coordinates lie within the bounds of any grid,\n * whether it's a puzzle grid, a wall grid, or any other two-dimensional array structure.\n * It ensures that operations on such grids do not access invalid indices.\n */\nexport function outOfBounds(x: number, y: number, xSize: number, ySize: number): boolean {\n    return x < 0 || x >= xSize || y < 0 || y >= ySize\n}","import { findSolution } from \"./utils\"\r\nimport { PuzzleData } from \"./types\"\r\n\r\nself.onmessage = (e: MessageEvent<PuzzleData>) => {\r\n    self.postMessage(findSolution(e.data))\r\n}"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","_slicedToArray","isArray","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","_e2","Cell","getSolutionError","puzzleData","cells","size","starCount","rows","columns","groups","error","_step","_iterator","entries","_step$value","STAR","starNeighbour","getNeighbouringIndices","find","index","undefined","indices","message","processTooManyStarsRule","processNotEnoughSpacesRule","findSimpleError","targetGroups","_step2","_iterator2","group","getStarCount","concat","_step3","_iterator3","getCellCount","BLANK","findSolution","cellIndexToGroupIndex","backup","guesses","res","findSolutionHelper","startIndex","arguments","console","log","pastUnfinishedGroup","applyNextSteps","neighbour","_step5","_iterator5","_step6","_iterator6","_step7","_iterator7","isSolved","_getCoords","getCoords","x","y","map","g","_getCoords2","X","pop","maxGuesses","nextStep","getNextStep","applyNextStep","cutoff","_step4","_iterator4","cellType","filter","confirmedPartitions","neighbours","range","Math","pow","getAllNeighbouringIndices","processLastSpacesRule","_step8","_iterator8","_step8$value","cell","type","processNoStarsLeftRule","_step9","_iterator9","_step9$value","findNeighbouringGroup","otherIndices","_step10","_iterator10","_step10$value","groupIndices","Set","processNoCrowdingRule","rowIndices","columnIndices","processBlockRule","_range","lineCount","_i2","_range2","start","processGroupsFillLinesRule","twoRowGroups","flat","twoColumnGroups","processConfirmedBlockRule","_step11","_iterator11","_step11$value","starCanBePlaced","some","getRemainingStarCount","_getCoords3","starsCanBePlaced","_step12","_iterator12","includes","getSharedNeighbour","_step13","_iterator13","_loop","otherNeighbours","_step14","_iterator14","every","_step16","_iterator16","_step17","_iterator17","lines","lineIndices","targetCount","_step15","_iterator15","add","findSharedGroups","groupIndex","groupsText","linesText","relevantGroups","_step18","_iterator18","remainingGroup","partitionCells","targets","_step19","starCountPerTarget","_iterator19","target","blankGroup","partitions","remainingStarCount","forEach","partition","addConfirmedPartition","multipleLeft","multipleGroup","baseMessage","replaceAll","_i4","_partitions","partitionToAdd","findIndex","supersetIndex","_step22","starCountPerGroup","_iterator22","_loop2","match","v","_ret","newCells","_getCoords6","_ref","_ref2","_ref3","_ref4","getIndex","floor","_step23","_iterator23","_step24","foundExisting","_iterator24","withinSquare","_getCoords7","_getCoords8","otherX","otherY","abs","stop","_","self","onmessage","postMessage","data"],"sourceRoot":""}