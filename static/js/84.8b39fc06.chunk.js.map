{"version":3,"file":"static/js/84.8b39fc06.chunk.js","mappings":"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","sources":["../.yarn/cache/@babel-runtime-npm-7.23.4-2e68957572-8eb6a6b236.zip/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../.yarn/cache/@babel-runtime-npm-7.23.4-2e68957572-8eb6a6b236.zip/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../.yarn/cache/@babel-runtime-npm-7.23.4-2e68957572-8eb6a6b236.zip/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../.yarn/cache/@babel-runtime-npm-7.23.4-2e68957572-8eb6a6b236.zip/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../.yarn/cache/@babel-runtime-npm-7.23.4-2e68957572-8eb6a6b236.zip/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../.yarn/cache/@babel-runtime-npm-7.23.4-2e68957572-8eb6a6b236.zip/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../.yarn/cache/@babel-runtime-npm-7.23.4-2e68957572-8eb6a6b236.zip/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","starbattle/types.ts","starbattle/utils.ts","starbattle/solver.worker.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","\r\nexport enum Cell {\r\n    BLANK,\r\n    STAR,\r\n    X,\r\n}\r\n\r\nexport type PuzzleStep = {\r\n    indices?: number[]\r\n    otherIndices?: number[]\r\n    type?: Cell\r\n    message?: string\r\n}\r\n\r\nexport type PuzzleData = {\r\n    cells: Cell[]\r\n    size: number\r\n    starCount: number\r\n    rows: number[][]\r\n    columns: number[][]\r\n    groups: number[][]\r\n    cellIndexToGroupIndex: number[]\r\n}","import { Cell, PuzzleData, PuzzleStep } from './types';\n\n/**\n * Analyzes a puzzle state to identify any rule violations.\n *\n * @param {PuzzleData} puzzleData - The current state of the puzzle, including cell configurations, \n *                                  puzzle size, star count, and structure of rows, columns, and groups.\n * @returns {PuzzleStep} Returns a PuzzleStep object containing error details if a violation is found; \n *                       otherwise, returns an empty object.\n *\n * This function checks for basic StarBattle puzzle rules, such as ensuring that stars are not adjacent \n * (even diagonally) and that each row, column, and group has the correct number of stars. If an error \n * is found, it returns the indices of the problematic cells and an error message.\n */\nexport function getSolutionError(puzzleData: PuzzleData): PuzzleStep {\n    const { cells, size, starCount, rows, columns, groups } = puzzleData\n    let error = findSimpleError()\n    if (error) return error\n    // return { message: \"Unsolvable\" }\n    return {}\n\n    function findSimpleError(): PuzzleStep | undefined {\n        // for each cell with star, surrounding cells must have no star\n        for (const [i, cell] of cells.entries()) {\n            if (cell !== Cell.STAR) continue\n            const starNeighbour = getNeighbouringIndices(size, i).find(index => cells[index] === Cell.STAR)\n            if (starNeighbour === undefined) continue\n            return {\n                indices: [i, starNeighbour],\n                message: \"Stars cannot be next to each other.\",\n            }\n        }\n        // each row, column, group must have at most n stars\n        let error = processTooManyStarsRule(rows, \"row\")\n        if (error) return error\n        error = processTooManyStarsRule(columns, \"column\")\n        if (error) return error\n        error = processTooManyStarsRule(groups, \"group\")\n        if (error) return error\n        error = processNotEnoughSpacesRule(rows, \"row\")\n        if (error) return error\n        error = processNotEnoughSpacesRule(columns, \"column\")\n        if (error) return error\n        error = processNotEnoughSpacesRule(groups, \"group\")\n        if (error) return error\n    }\n\n    function processTooManyStarsRule(targetGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of targetGroups) {\n            if (getStarCount(group, cells) > starCount) {\n                return {\n                    indices: group,\n                    message: `This ${name} contains too many stars.`\n                }\n            }\n        }\n    }\n\n    function processNotEnoughSpacesRule(targetGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of targetGroups) {\n            if (starCount - getStarCount(group, cells) > getCellCount(group, cells, Cell.BLANK)) {\n                return {\n                    indices: group,\n                    message: `This ${name} contains too few blank spaces.`\n                }\n            }\n        }\n    }\n\n}\n\n/**\n * Attempts to find a solution for the given puzzle data and returns the solved state as an array of cells.\n *\n * @param {PuzzleData} puzzleData - The puzzle data, including the current state of the puzzle grid\n *                                  and configuration settings like puzzle size and star count.\n * @returns {Cell[] | undefined} Returns an array of cells representing the solved state of the puzzle\n *                               if a solution is found. Each cell in the array represents a specific\n *                               state (e.g., empty, star, etc.) in the puzzle grid. Returns undefined\n *                               if no solution is found.\n *\n * This function applies solving algorithms to the provided puzzle data in an attempt to find a valid\n * solution. It employs logical rules and techniques specific to StarBattle puzzles to determine the\n * placement of stars. If a solution is found, the function returns the solved state, which can be used\n * to update the puzzle grid in the user interface. If the puzzle is unsolvable, it returns undefined.\n */\nexport function findSolution(puzzleData: PuzzleData): Cell[] | undefined  {\n    const { size, starCount, rows, columns, groups, cellIndexToGroupIndex } = puzzleData\n    let backup = puzzleData.cells\n    puzzleData.cells = backup.slice()\n    let { cells } = puzzleData\n    const guesses: number[] = []\n    const res = findSolutionHelper()\n    puzzleData.cells = backup\n    console.log(\"After solution helper, res:\", res)\n    if (res) return res\n\n    function findSolutionHelper(startIndex: number = 0): Cell[] | undefined {\n        console.log(\"In findSolutionHelper\", startIndex)\n        // Early failure check\n        if (pastUnfinishedGroup(startIndex, groups, cells, starCount)) return\n        // Use logic where possible\n        const err = applyNextSteps(puzzleData)\n        if (err !== undefined) return\n        console.log(\"After logic\")\n        // Successful base case\n        if (isSolved(puzzleData)) return cells\n        // Otherwise, guess and check\n        for (let i = startIndex; i < cells.length; i++) {\n            if (pastUnfinishedGroup(i, groups, cells, starCount)) break\n            if (cells[i] !== Cell.BLANK) continue\n            // getNextStep should have already marked the following with X, so they shouldn't need to be checked\n            if (getNeighbouringIndices(size, i).find(neighbour => cells[neighbour] === Cell.STAR)) continue\n            if (getStarCount(groups[cellIndexToGroupIndex[i]], cells) === starCount) continue\n            const {x, y} = getCoords(i, size)\n            if (getStarCount(rows[y], cells) === starCount) continue\n            if (getStarCount(columns[x], cells) === starCount) continue\n            const backup = cells.slice()\n            cells[i] = Cell.STAR\n            guesses.push(i)\n            console.log(\"guesses,\", guesses.map(g => {\n                const { x, y } = getCoords(g, size)\n                return [g, x, y]\n            }))\n            const res = findSolutionHelper(i + 1)\n            if (res) {\n                return res\n            }\n            // Guess was wrong\n            cells = backup\n            puzzleData.cells = cells\n            cells[i] = Cell.X\n            guesses.pop()\n            const err = applyNextSteps(puzzleData)\n            if (err !== undefined) return\n        }\n        // Unsuccessful base case\n    }\n}\n\nfunction applyNextSteps(puzzleData: PuzzleData, maxGuesses: number = 0) {\n    const backup = puzzleData.cells\n    puzzleData.cells = backup.slice()\n    try {\n        while (true) {\n            let nextStep = getNextStep(puzzleData, maxGuesses)\n            const newCells = applyNextStep(puzzleData.cells, nextStep, true)\n            if (!newCells) return\n            const error = getSolutionError(puzzleData)\n            if (error.message) {\n                console.log(\"Found error\", error)\n                return error\n            }\n        }\n    } finally {\n        puzzleData.cells = backup\n    }\n}\n\nfunction pastUnfinishedGroup(cutoff: number, groups: number[][], cells: Cell[], starCount: number): boolean {\n    for (const group of groups) {\n        if (getStarCount(group, cells) === starCount) continue\n        if (group[group.length - 1] < cutoff) {\n            console.log(`cutoff: ${cutoff} group: ${group}`)\n            return true\n        }\n    }\n    return false\n}\n\n/**\n * Determines if the puzzle is solved.\n *\n * @param {PuzzleData} puzzleData - The current state of the puzzle, including the grid configuration \n *                                  and other relevant data.\n * @returns {boolean} Returns true if the puzzle is correctly solved, otherwise false.\n *\n * This function checks the entire state of the puzzle to determine if it meets all the criteria for \n * being solved. It evaluates if the correct number of stars are placed according to the game rules and \n * verifies that no rule violations exist in the current configuration.\n */\nexport function isSolved(puzzleData: PuzzleData): boolean {\n    const { cells, size, starCount, rows, columns, groups } = puzzleData\n    // for each cell that have a star, surrounding cells must have no star\n    for (let i = 0; i < cells.length; i++) {\n        if (cells[i] === Cell.STAR) {\n            if (getNeighbouringIndices(size, i).find(neighbour => cells[neighbour] === Cell.STAR)) {\n                return false\n            }\n        }\n    }\n    // each row, column, group must have exactly n stars\n    for (const row of rows) {\n        if (getStarCount(row, cells) != starCount) return false\n    }\n    for (const column of columns) {\n        if (getStarCount(column, cells) != starCount) return false\n    }\n    for (const group of groups) {\n        if (getStarCount(group, cells) != starCount) return false\n    }\n    return true\n}\n\n/**\n * Counts the number of stars in a specified group of cells.\n *\n * @param {number[]} group - An array of indices representing a group of cells in the puzzle.\n * @param {Cell[]} cells - An array of cells representing the current state of the puzzle.\n * @returns {number} Returns the count of stars present in the specified group.\n *\n * This function calculates the number of cells in the provided group that are marked as stars. It is\n * commonly used to verify puzzle rules related to star count in rows, columns, or regions.\n */\nfunction getStarCount(group: number[], cells: Cell[]): number {\n    return getCellCount(group, cells, Cell.STAR)\n}\n\n/**\n * Counts the number of cells of a specific type in a given group.\n *\n * @param {number[]} group - An array of indices representing a group of cells in the puzzle.\n * @param {Cell[]} cells - An array of cells representing the current state of the puzzle.\n * @param {Cell} cellType - The type of cell to count (e.g., Cell.STAR, Cell.EMPTY).\n * @returns {number} Returns the count of cells of the specified type in the group.\n *\n * This function calculates how many cells of a specific type are present in the provided group.\n * It is a general utility function used to count various types of cells, like stars or empty cells,\n * in a specific part of the puzzle.\n */\nfunction getCellCount(group: number[], cells: Cell[], cellType: Cell): number {\n    return group.filter(index => cells[index] === cellType).length\n}\n\n/**\n * Determines the next logical step in solving the puzzle.\n *\n * @param {PuzzleData} puzzleData - The current state of the puzzle, including the grid configuration \n *                                  and other relevant data.\n * @returns {PuzzleStep} Returns a PuzzleStep object representing the next step in the puzzle-solving\n *                       process. This includes details about the action to be taken and any relevant\n *                       indices or messages.\n *\n * This function analyzes the current state of the puzzle and identifies the next logical move that\n * brings the puzzle closer to a solution. It applies various solving techniques and rules specific to\n * StarBattle puzzles to deduce this next step. The returned PuzzleStep can then be used to update the\n * puzzle state or guide the user on what action to take next.\n */\nexport function getNextStep(puzzleData: PuzzleData, maxGuesses: number = 0): PuzzleStep {\n    const { cells, size, starCount, rows, columns, groups, cellIndexToGroupIndex } = puzzleData\n    // apply each rule and return first match\n    // for all groups, rows, columns, return if remainingStars == remainingSpaces\n    const confirmedPartitions: number[][] = []\n    const neighbours = getAllNeighbouringIndices(size)\n    let nextStep = processLastSpacesRule(groups, \"group\")\n    if (nextStep) return nextStep\n    nextStep = processLastSpacesRule(rows, \"row\")\n    if (nextStep) return nextStep\n    nextStep = processLastSpacesRule(columns, \"column\")\n    if (nextStep) return nextStep\n\n    for (const [i, cell] of cells.entries()) {\n        if (cell === Cell.X) continue\n        if (cell !== Cell.STAR) continue\n        const indices = getNeighbouringIndices(size, i).filter(index => cells[index] !== Cell.X)\n        if (indices.length === 0) continue\n        return {\n            indices,\n            type: Cell.X,\n            message: `Stars cannot be placed in cells neighbouring a star (including diagonals).`\n        }\n    }\n\n    nextStep = processNoStarsLeftRule(groups, \"group\")\n    if (nextStep) return nextStep\n    nextStep = processNoStarsLeftRule(rows, \"row\")\n    if (nextStep) return nextStep\n    nextStep = processNoStarsLeftRule(columns, \"column\")\n    if (nextStep) return nextStep\n    \n    for (const [i, cell] of cells.entries()) {\n        if (cell === Cell.X) continue\n        const group = findNeighbouringGroup(i)\n        if (!group) continue\n        return {\n            indices: [i],\n            otherIndices: group,\n            type: Cell.X,\n            message: `A star cannot be placed here. Otherwise, not enough stars can be placed within this group.`\n        }\n    }\n    // For each blank cell, imagine what would happen if it was a star - set neighbours to x, check # of blocks for the groups/columns/rows they are in\n    for (const [i, cell] of cells.entries()) {\n        if (cell !== Cell.BLANK) continue\n        const neighbours = getNeighbouringIndices(size, i).filter(index => cells[index] === Cell.BLANK)\n        const groupIndices = new Set(neighbours.map(index => cellIndexToGroupIndex[index]))\n        const relevantGroups = Array.from(groupIndices).map(index => groups[index])\n        nextStep = processNoCrowdingRule(i, neighbours, relevantGroups, \"group\")\n        if (nextStep) return nextStep\n        const rowIndices = new Set(neighbours.map(index => getCoords(index, size).y))\n        const relevantRows = Array.from(rowIndices).map(index => rows[index])\n        nextStep = processNoCrowdingRule(i, neighbours, relevantRows, \"row\")\n        if (nextStep) return nextStep\n        const columnIndices = new Set(neighbours.map(index => getCoords(index, size).x))\n        const relevantColumns = Array.from(columnIndices).map(index => columns[index])\n        // console.log(i, neighbours, columnIndices, relevantColumns)\n        nextStep = processNoCrowdingRule(i, neighbours, relevantColumns, \"column\")\n        if (nextStep) return nextStep\n    }\n    nextStep = processBlockRule(groups, \"group\")\n    if (nextStep) return nextStep\n    nextStep = processBlockRule(rows, \"row\")\n    if (nextStep) return nextStep\n    nextStep = processBlockRule(columns, \"column\")\n    if (nextStep) return nextStep\n    for (const lineCount of range(1, size)) {\n        for (const start of range(0, size - lineCount + 1)) {\n            // console.log(\"lineCount\", lineCount, \"start\", start, \"end\", size - lineCount + 1)\n            nextStep = processGroupsFillLinesRule(rows.slice(start, start + lineCount), \"row\")\n            if (nextStep) return nextStep\n            nextStep = processGroupsFillLinesRule(columns.slice(start, start + lineCount), \"column\")\n            if (nextStep) return nextStep\n        }\n    }\n    const twoRowGroups = range(0, size - 2 + 1).map(start => rows.slice(start, start + 2).flat())\n    nextStep = processBlockRule(twoRowGroups, \"row\", 2 * starCount)\n    if (nextStep) return nextStep\n    const twoColumnGroups = range(0, size - 2 + 1).map(start => columns.slice(start, start + 2).flat())\n    nextStep = processBlockRule(twoColumnGroups, \"column\", 2 * starCount)\n    if (nextStep) return nextStep\n    nextStep = processConfirmedBlockRule(twoRowGroups, \"row\", 2 * starCount)\n    if (nextStep) return nextStep\n    nextStep = processConfirmedBlockRule(twoColumnGroups, \"column\", 2 * starCount)\n    if (nextStep) return nextStep\n    nextStep = processConfirmedBlockRule(groups, \"group\", 2 * starCount)\n    if (nextStep) return nextStep\n    // nextStep = processCombinedGroupBlockRule()\n    // if (nextStep) return nextStep\n    // TODO: this can be slow, especially when maxGuesses > 1\n    if (maxGuesses > 0) {\n        for (const [i, cell] of cells.entries()) {\n            if (cell !== Cell.BLANK) continue\n            cells[i] = Cell.STAR\n            const error = applyNextSteps(puzzleData, maxGuesses - 1)\n            cells[i] = Cell.BLANK\n            // A star here would lead to an error, so there can be no star here\n            if (error)\n                return {\n                    indices: [i],\n                    type: Cell.X,\n                    message: `A star cannot be placed here. Otherwise, a rule violation will eventually occur.`\n                }\n        }\n    }\n    return {message: 'Unknown'}\n\n    function starCanBePlaced(i: number) {\n        if (cells[i] !== Cell.BLANK) return false\n        if (neighbours[i].some(index => cells[index] === Cell.STAR)) return false\n        if (getRemainingStarCount(cells, groups[cellIndexToGroupIndex[i]], starCount) === 0) return false\n        const { x, y } = getCoords(i, size)\n        if (getRemainingStarCount(cells, rows[y], starCount) === 0) return false\n        if (getRemainingStarCount(cells, columns[x], starCount) === 0) return false\n        return true\n    }\n\n    function starsCanBePlaced(indices: number[]) {\n        for (const i of indices) {\n            if (!starCanBePlaced(i)) return false\n            if (neighbours[i].some(index => indices.includes(index))) return false\n        }\n        return true\n    }\n    \n    function getSharedNeighbour(indices: number[]): number[] {\n        let neighbours = getNeighbouringIndices(size, indices[0])\n        for (const i of indices.slice(1)) {\n            let otherNeighbours = getNeighbouringIndices(size, i)\n            neighbours = neighbours.filter(index => otherNeighbours.includes(index))\n        }\n        return neighbours\n    }\n\n    function findNeighbouringGroup(i: number): number[] | undefined {\n        const neighbours = getNeighbouringIndices(size, i)\n        for (let group of groups) {\n            group = group.filter(index => cells[index] === Cell.BLANK)\n            if (group.length === 0) continue\n            if (group.every(index => neighbours.includes(index))) return group\n        }\n    }\n\n    function findSharedRow(group: number[]): number | undefined {\n        const {y} = getCoords(group[0], size)\n        if (group.every(index => cells[index] === Cell.X || getCoords(index, size).y === y)) return y\n    }\n\n    function findSharedColumn(group: number[]): number | undefined {\n        const {x} = getCoords(group[0], size)\n        if (group.every(index => cells[index] === Cell.X || getCoords(index, size).x === x)) return x\n    }\n\n    function findSharedGroups(indices: number[], targetCount: number): number[] | undefined {\n        const groups: Set<number> = new Set()\n        for (const index of indices) {\n            groups.add(cellIndexToGroupIndex[index])\n            if (groups.size > targetCount) return\n        }\n        return Array.from(groups)\n    }\n\n    function processLastSpacesRule(targetGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of targetGroups) {\n            const indices = group.filter(index => cells[index] === Cell.BLANK)\n            if (indices.length === 0) continue\n            if (!starsCanBePlaced(indices)) continue\n            if (getRemainingStarCount(cells, group, starCount) === indices.length)\n                return {\n                    indices,\n                    type: Cell.STAR,\n                    message: `The remaining stars in this ${name} can only be placed here.`\n                }\n        }\n    }\n\n    function processNoStarsLeftRule(targetGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of targetGroups) {\n            if (getRemainingStarCount(cells, group, starCount) === 0) {\n                const indices = group.filter(index => cells[index] === Cell.BLANK)\n                if (indices.length === 0) continue\n                return {\n                    indices,\n                    type: Cell.X,\n                    message: `No more stars can be placed in this ${name}.`\n                }\n            }\n        }\n    }\n\n    /* For example, if all the cells in 2 adjacent rows are in 2 groups, the stars in those groups\n        must be in those rows. The rest of the cells in those groups cannot contain stars.\n     */\n    function processGroupsFillLinesRule(lines: number[][], name: string): PuzzleStep | undefined {\n        const lineIndices = lines.flat().filter(index => cells[index] !== Cell.X)\n        const groupIndices = findSharedGroups(lineIndices, lines.length)\n        if (typeof groupIndices === 'undefined') return\n        // console.log(\"line\", lineIndices, \"group\", groupIndices, groupIndices.map(groupIndex => groups[groupIndex]).flat())\n        const indices = groupIndices.map(groupIndex => groups[groupIndex])\n            .flat()\n            .filter(index => !lineIndices.includes(index) && cells[index] !== Cell.X)\n        if (indices.length === 0) return\n        const groupsText = lines.length > 1 ? \"these groups\" : \"this group\"\n        const linesText = lines.length > 1 ? `these ${name}s` : `this ${name}`\n        return {\n            indices,\n            otherIndices: lineIndices,\n            type: Cell.X,\n            message: `Stars cannot be placed in ${groupsText} outside ${linesText}. Otherwise, there will not be enough stars in ${linesText}.`\n        }\n    }\n\n    function processNoCrowdingRule(i: number, neighbours: number[], relevantGroups: number[][], name: string): PuzzleStep | undefined {\n        for (const group of relevantGroups) {\n            const remainingGroup = group.filter(index => cells[index] === Cell.BLANK && !neighbours.includes(index))\n            // console.log(i, name, group, remainingGroup)\n            const partitions = partitionCells(size, remainingGroup)\n            if (partitions.length >= getRemainingStarCount(cells, group, starCount)) continue\n            return {\n                indices: [i],\n                otherIndices: group,\n                type: Cell.X,\n                message: `A star cannot be placed here. Otherwise the indicated ${name} will not have enough room for stars.`\n            }\n        }\n    }\n\n    function processBlockRule(targets: number[][], name: string, starCountPerTarget: number = starCount): PuzzleStep | undefined {\n        for (const target of targets) {\n            const blankGroup = target.filter(index => cells[index] === Cell.BLANK)\n            const partitions = partitionCells(size, blankGroup)\n            const remainingStarCount = getRemainingStarCount(cells, target, starCountPerTarget)\n            // console.log(\"target\", target, \"parts\", partitions, \"remainingStarCount\", remainingStarCount)\n            if (partitions.length !== remainingStarCount) continue\n            partitions.forEach(partition => addConfirmedPartition(partition))\n            const multipleLeft = remainingStarCount > 1\n            const multipleGroup = starCountPerTarget > starCount\n            const baseMessage = `There can be at most 1 star in each 2x2 block. When the remaining space \n                within ${multipleGroup ? 'these': 'this'}  ${name}${multipleGroup ? 's' : ''} is split into blocks at most 2x2 in size, \n                there ${multipleLeft ? 'are' : 'is'} only ${remainingStarCount} block${multipleLeft ? 's' : ''}, \n                which is equal to the number of remaining stars. \n                Therefore, each block must contain a star.`.replaceAll('\\n', '')\n            for (const partition of partitions) {\n                if (partition.length === 1) {\n                    if (starCanBePlaced(partition[0]))\n                        return {\n                            indices: partition,\n                            otherIndices: target,\n                            type: Cell.STAR,\n                            message: baseMessage + ` This block only has one space, so it must be a star.`\n                        }\n                }\n                const indices = getSharedNeighbour(partition).filter(index => cells[index] != Cell.X)\n                if (indices.length === 0) continue\n                return {\n                    indices,\n                    otherIndices: blankGroup,\n                    type: Cell.X,\n                    message: baseMessage + ` If stars are placed here, there will be no place to put a star in this block.`\n                }\n            }\n        }\n    }\n\n    // The block rule can be applied to multiple groups joined as one.\n    // There may be fewer partitions as some may stretch across group borders\n    // TODO: too slow; is there a faster way?\n    function processCombinedGroupBlockRule(): PuzzleStep | undefined {\n        // For each group, find neighbours (with greater index)\n        const groupNeighbours = getGroupNeighbours()\n        console.log(groupNeighbours)\n        // Choose # of groups to combine\n        for (let groupCount = 2; groupCount <= groups.length; groupCount++) {\n            // For each selection of groups, partition\n            console.log(\"groupCount\", groupCount)\n            for (const i of range(0, groups.length - groupCount + 1)) {\n                const selections = getSelections([[i]], groupCount)\n                console.log(i, selections)\n                if (selections.length === 0) continue\n                const combinedGroups = selections.map(selection => {\n                    return selection.map(groupIndex => groups[groupIndex]).flat()\n                })\n                const nextStep = processBlockRule(combinedGroups, \"group\", groupCount * starCount)\n                if (nextStep) return nextStep\n            }\n\n        }\n\n        // gets a combination of neighbouring groups\n        // TODO: currently gets all paths, but is there a way to get combinations instead?\n        function getSelections(inProgress: number[][], groupCount: number): number[][] {\n            if (inProgress.length === 0) return inProgress\n            if (inProgress[0].length === groupCount) return inProgress\n            const selections: number[][] = []\n            for (const selection of inProgress) {\n                const candidates = getCandidates(selection)\n                if (candidates.length === 0) continue\n                for (const candidate of candidates) {\n                    selections.push([...selection, candidate])\n                }\n            }\n            return getSelections(selections, groupCount)\n        }\n\n        function getCandidates(selection: number[]) {\n            return Array.from(new Set(selection.map(index => groupNeighbours[index])\n                                               .flat()\n                                               .filter(index => !selection.includes(index))))\n        }\n    }\n\n    function getGroupNeighbours() {\n        const blankGroups = groups.map(group => group.filter(i => cells[i] === Cell.BLANK))\n        // true if some blank cell in group is next to some blank cell in other\n        return blankGroups.map((group1, index1) => {\n            return blankGroups.map((group2, index2) => {\n                if (index1 >= index2) return -1\n                return group1.some(i => group2.some(j => isNeighbour(i, j)))\n                    ? index2\n                    : -1\n            }).filter(val => val !== -1)\n        })\n    }\n\n    function isNeighbour(i: number, j: number) {\n        return getNeighbouringIndices(size, i).includes(j)\n    }\n    \n    function addConfirmedPartition(partitionToAdd: number[]) {\n        const subsetIndex = confirmedPartitions.findIndex(partition => {\n            return partition.length <= partitionToAdd.length\n                && partition.every(index => partitionToAdd.includes(index))\n        })\n        if (subsetIndex > -1) return\n        const supersetIndex = confirmedPartitions.findIndex(partition => {\n            return partition.length > partitionToAdd.length\n                && partitionToAdd.every(index => partition.includes(index))\n        })\n        if (supersetIndex > -1) return confirmedPartitions[supersetIndex] = partitionToAdd\n        confirmedPartitions.push(partitionToAdd)\n    }\n\n    /* When processing the block rule, for example in 2 rows, suppose we find partitions that match the remaining star count.\n        These partitions are confirmed to have a star in each. When partitioning 2 columns for example, if we find one of the\n        confirmed partitions again with 1 remaining star in the 2 columns, since we know a star has to be in that partition,\n        we can exclude the spaces in the 2 columns outside the partition.\n     */\n    function processConfirmedBlockRule(groups: number[][], name: string, starCountPerGroup: number = starCount): PuzzleStep | undefined {\n        for (const group of groups) {\n            const remainingStarCount = getRemainingStarCount(cells, group, starCountPerGroup)\n            if (remainingStarCount !== 1) continue\n            const blankGroup = group.filter(index => cells[index] === Cell.BLANK)\n            const match = confirmedPartitions.find(partition => partition.every(index => group.includes(index)))\n            if (match === undefined) continue\n            const indices = blankGroup.filter(index => !match.includes(index))\n            if (indices.length === 0) continue\n            const multipleGroup = starCountPerGroup > starCount\n            return {\n                indices,\n                otherIndices: blankGroup,\n                type: Cell.X,\n                message: `There can be at most 1 star in each 2x2 block. The indicated block is confirmed to have a star \n                            from splitting some columns, rows, or groups into blocks, so we can exclude the spaces within \n                            ${multipleGroup ? 'these': 'this'} ${name}${multipleGroup ? 's' : ''} outside the block .`.replaceAll('\\n', '')\n            }\n        }\n    }\n}\n\n/**\n * Calculates the number of stars yet to be placed in a specific group.\n *\n * @param {Cell[]} cells - An array of cells representing the current state of the puzzle.\n * @param {number[]} group - An array of indices representing a group of cells in the puzzle.\n * @param {number} starCountPerGroup - The required number of stars per group.\n * @returns {number} The number of stars still needed to meet the required count in the group.\n *\n * This function determines how many more stars need to be placed in a given group to meet the\n * specified star count. It is useful for guiding the puzzle solving process.\n */\nfunction getRemainingStarCount(cells: Cell[], group: number[], starCountPerGroup: number) {\n    return starCountPerGroup - group.filter(index => cells[index] === Cell.STAR).length\n}\n\n/**\n * Applies the next step in the puzzle solving process to the puzzle grid.\n *\n * @param {Cell[]} cells - The current state of the puzzle grid.\n * @param {PuzzleStep} nextStep - The next step to apply, including indices and cell types.\n * @param {boolean} inPlace - Whether to modify the cells array in place. Default is false.\n * @returns {Cell[] | undefined} The updated puzzle grid after applying the step, or undefined if no action is taken.\n *\n * This function updates the puzzle grid based on the provided next step, which may involve placing or removing\n * stars or other actions. If 'inPlace' is true, the original grid is modified; otherwise, a new grid is returned.\n */\nexport function applyNextStep(cells: Cell[], nextStep: PuzzleStep, inPlace: boolean = false) {\n    const newCells = inPlace ? cells : cells.slice()\n    const { indices, type } = nextStep\n    if (indices === undefined || indices.length === 0 || type === undefined) return\n    indices.forEach(index => newCells[index] = type)\n    return newCells\n}\n\n/**\n * Gets the indices of all neighboring cells for a given cell in the puzzle grid.\n *\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @param {number} i - The index of the cell for which to find neighbors.\n * @returns {number[]} An array of indices representing neighboring cells.\n *\n * This function calculates the indices of all cells adjacent (including diagonally) to a given cell\n * in the grid. It is used to check puzzle rules related to neighboring cells.\n */\nexport function getNeighbouringIndices(size: number, i: number): number[] {\n    const { x, y } = getCoords(i, size)\n    return [\n        [x - 1, y - 1],\n        [x, y - 1],\n        [x + 1, y - 1],\n        [x - 1, y],\n        [x + 1, y],\n        [x - 1, y + 1],\n        [x, y + 1],\n        [x + 1, y + 1],\n    ].filter(([x, y]) => x >= 0 && x < size && y >= 0 && y < size)\n    .map(([x, y]) => getIndex(x, y, size))\n}\n\n/**\n * Generates a list of neighboring indices for every cell in the puzzle grid.\n *\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @returns {Cell[][]} An array where each element is an array of neighboring indices for each cell in the grid.\n *\n * This function is a utility to pre-calculate and store all neighboring indices for each cell in the grid,\n * potentially optimizing operations that frequently require this information.\n */\nexport function getAllNeighbouringIndices(size: number): Cell[][] {\n    return range(0, size**2).map(i => getNeighbouringIndices(size, i))\n}\n\n/**\n * Converts a linear index into x, y coordinates in the puzzle grid.\n *\n * @param {number} i - The linear index to convert.\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @returns {{ x: number, y: number }} An object containing the x and y coordinates corresponding to the index.\n *\n * This function is used to translate between a linear array representation of the puzzle grid\n * and a two-dimensional coordinate system.\n */\nexport function getCoords(i: number, size: number): { x: number, y: number} {\n    return {\n        x: i % size,\n        y: Math.floor(i / size),\n    }\n}\n\n/**\n * Converts x, y coordinates to a linear index in the puzzle grid.\n *\n * @param {number} x - The x coordinate.\n * @param {number} y - The y coordinate.\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @returns {number} The linear index corresponding to the x, y coordinates.\n *\n * This function is the inverse of 'getCoords', translating two-dimensional coordinates into\n * a linear index in the puzzle's array representation.\n */\nexport function getIndex(x: number, y: number, size: number): number {\n    return y * size + x\n}\n\n/**\n * Partitions a set of cell indices into groups where each group forms a 2x2 block.\n *\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @param {number[]} indices - The indices of cells to be partitioned.\n * @returns {number[][]} An array of groups, each group being a 2x2 block of cell indices.\n *\n * This function is used in solving processes to group cells into blocks that conform to the\n * StarBattle puzzle rule: each 2x2 block can contain at most one star.\n */\nexport function partitionCells(size: number, indices: number[]): number[][] {\n    const partitions: number[][] = []\n    // for each index\n    for (const i of indices) {\n        // if it fits into existing partitions, add it\n        let foundExisting = false\n        for (const partition of partitions) {\n            if (withinSquare(size, i, partition)) {\n                partition.push(i)\n                foundExisting = true\n                break\n            }\n        }\n        // if not, make a new partition\n        if (!foundExisting) {\n            partitions.push([i])\n        }\n    }\n    // todo: guarantee that # of partitions is minimalized\n    return partitions\n}\n\n/**\n * Determines if a given cell is within a 2x2 square area of all cells in a group.\n *\n * @param {number} size - The size of the puzzle grid (assumed to be square).\n * @param {number} i - The index of the cell to check.\n * @param {number[]} group - An array of indices representing a group of cells in the puzzle.\n * @returns {boolean} Returns true if the specified cell is within a 2x2 square area of every cell in the group.\n *\n * This function checks whether the cell at index 'i' is within a 1-cell radius (forming a 2x2 square)\n * of every other cell in the provided group. It is useful for implementing rules that depend on the\n * proximity of cells within the puzzle grid, such as ensuring that stars in a StarBattle puzzle are not\n * placed too close to each other.\n */\nfunction withinSquare(size: number, i: number, group: number[]) {\n    const { x, y } = getCoords(i, size)\n    return group.every(index => {\n        const {x: otherX, y: otherY} = getCoords(index, size)\n        return (Math.abs(x - otherX) <= 1 && Math.abs(y - otherY) <= 1)\n    })\n}\n\n// Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#sequence_generator_range\n/**\n * Creates an array of numbers within a specified range.\n *\n * @param {number} start - The start value of the range.\n * @param {number} stop - The end value of the range.\n * @param {number} step - The step size between each number in the range.\n * @returns {number[]} An array containing the sequence of numbers.\n *\n * This utility function generates a sequence of numbers starting from 'start', ending at 'stop',\n * and incrementing by 'step'. It is useful for creating numeric arrays for iteration and indexing.\n */\nexport function range(start: number, stop: number, step: number = 1): number[] {\n    return Array.from({ length: (stop - 1 - start) / step + 1 }, (_, i) => start + i * step)\n}\n\n/**\n * Checks if the given coordinates are out of bounds for a grid of specified dimensions.\n *\n * @param {number} x - The x coordinate to check.\n * @param {number} y - The y coordinate to check.\n * @param {number} xSize - The horizontal size (width) of the grid.\n * @param {number} ySize - The vertical size (height) of the grid.\n * @returns {boolean} True if the coordinates are out of bounds, false otherwise.\n *\n * This function is used to validate whether given coordinates lie within the bounds of any grid,\n * whether it's a puzzle grid, a wall grid, or any other two-dimensional array structure.\n * It ensures that operations on such grids do not access invalid indices.\n */\nexport function outOfBounds(x: number, y: number, xSize: number, ySize: number): boolean {\n    return x < 0 || x >= xSize || y < 0 || y >= ySize\n}","import { findSolution } from \"./utils\"\r\nimport { PuzzleData } from \"./types\"\r\n\r\nself.onmessage = (e: MessageEvent<PuzzleData>) => {\r\n    self.postMessage(findSolution(e.data))\r\n}"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","_slicedToArray","isArray","r","l","t","Symbol","iterator","e","u","a","f","next","done","push","value","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","_e","err","normalCompletion","didErr","step","_e2","Cell","getSolutionError","puzzleData","cells","size","starCount","rows","columns","groups","error","_step","_iterator","entries","_step$value","STAR","starNeighbour","getNeighbouringIndices","find","index","undefined","indices","message","processTooManyStarsRule","processNotEnoughSpacesRule","findSimpleError","targetGroups","_step2","_iterator2","group","getStarCount","concat","_step3","_iterator3","getCellCount","BLANK","findSolution","cellIndexToGroupIndex","backup","guesses","res","findSolutionHelper","startIndex","arguments","console","log","pastUnfinishedGroup","applyNextSteps","neighbour","_step5","_iterator5","_step6","_iterator6","_step7","_iterator7","isSolved","_getCoords","getCoords","x","y","map","g","_getCoords2","X","pop","maxGuesses","nextStep","getNextStep","applyNextStep","cutoff","_step4","_iterator4","cellType","filter","confirmedPartitions","neighbours","range","Math","pow","getAllNeighbouringIndices","processLastSpacesRule","_step8","_iterator8","_step8$value","cell","type","processNoStarsLeftRule","_step9","_iterator9","_step9$value","findNeighbouringGroup","otherIndices","_step10","_iterator10","_step10$value","groupIndices","Set","processNoCrowdingRule","rowIndices","columnIndices","processBlockRule","_i","_range","lineCount","_i2","_range2","start","processGroupsFillLinesRule","twoRowGroups","flat","twoColumnGroups","processConfirmedBlockRule","_step11","_iterator11","_step11$value","starCanBePlaced","some","getRemainingStarCount","_getCoords3","starsCanBePlaced","_step12","_iterator12","includes","getSharedNeighbour","_step13","_iterator13","_loop","otherNeighbours","_step14","_iterator14","every","_step16","_iterator16","_step17","_iterator17","lines","lineIndices","targetCount","_step15","_iterator15","add","findSharedGroups","groupIndex","groupsText","linesText","relevantGroups","_step18","_iterator18","remainingGroup","partitionCells","targets","_step19","starCountPerTarget","_iterator19","target","blankGroup","partitions","remainingStarCount","forEach","partition","addConfirmedPartition","multipleLeft","multipleGroup","baseMessage","replaceAll","_i4","_partitions","partitionToAdd","findIndex","supersetIndex","_step22","starCountPerGroup","_iterator22","_ret","_loop2","match","v","newCells","_getCoords6","_ref","_ref2","_ref3","_ref4","getIndex","floor","_step23","_iterator23","_step24","foundExisting","_iterator24","withinSquare","_getCoords7","_getCoords8","otherX","otherY","abs","stop","_","self","onmessage","postMessage","data"],"sourceRoot":""}